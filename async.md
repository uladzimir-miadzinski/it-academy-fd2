## Асинхронность. Промисы. Async/Await

Задания выполняется в папке репозитория `/js/async`.  
Для каждого задания создается файл с номером задания по списку, к примеру `/js/async/task-1.js`  
В коде каждого файла с решением в самом верху в комментарии добавьте текст решаемого задания.  
В ответ на задание прикрепить ссылку на Pull-Request

### Теория:
* https://learn.javascript.ru/async
* https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise
* https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Using_promises

### Задания:
1. Создайте промис, который постоянно находиться в состоянии pending.  
В конструкторе промиса выведите в консоль сообщение "Promise is created".
1. Создайте промис, который после создания сразу же переходит в состояние resolve и возвращает строку 'Promise Data'.  
Получите данные промиса и выведите их в консоль
1. Создайте промис, который после создания сразу же переходит в состояние rejected и возвращает строку 'Promise Error'.
Получите данные промиса и выведите их в консоль
1. Создайте промис, который переходит в состояние resolved через 3с. (Используйте setTimeout) и возвращает строку 'Promise Data'.  
Получите данные промиса и выведите их в консоль
1. Для браузера. Создайте литерал объекта handlePromise со следующими свойствами: promise, resolve, reject, onSuccess, onError.  
Проинициализируйте первые три свойства null, а последние два функциями, которые принимают один параметр и выводят в консоль сообщения:  
    * первая - `Promise is resolved with data: ${paramName}`
    * вторая - `Promise is rejected with error: ${paramName}`  
Создайте три кнопки и три обработчика события click для этих кнопок.  
Первый обработчик, создает промис, заполняет первые три свойства, описаного выше объекта: 
    * свойство promise получает новый созданный промис,
    * свойства resolve и reject получают ссылки на соответствующие функции resolve и reject.   
Следующие два обработчика запускают методы resolve и reject.
1. Создайте промис, который через 1 с возвращает строку "My name is".  
Создайте функцию onSuccess, которая получает один параметр, прибавляет к нему Ваше имя и возвращает новую строку из функции.  
Создайте функцию print, которая выводит в консоль значение своего параметра.  
Добавьте два метода then и зарегистрируйте созданные функции.
1. Используйте предыдущий код. Добавьте в функци onSuccess генерацию исключения. Обработайте даное исключение, используя catch.  
Обратите внимание, что метод print при этом не выполняется.
1. Напишите функцию getPromiseData, которая принимает один параметр - промис.  
Функция получает значение промиса и выводит его в консоль. Объявите объект со свойтвом name и значением Anna.
Создайте врапер в виде промиса для этого объекта и вызовите для него функцию getPromiseData.
1. Создайте два промиса. Первый промис возвращает объект `{ name: "Anna" }` через 2с, а второй промис возвращает объект `{age: 16}` через 3 с.  
Получите результаты работы двух промисов, объедините свойства объектов и выведите в консоль. Используйте Promise.all.
1. Используйте предыдущее задание. Пусть теперь второй промис переходит в состояние rejected со значением "Promise Error".  
Измените код, чтобы обработать эту ситуацию. Используйте Promise.allSettled 
1. Для браузера. Создайте промис, который перейдет в состояние resolve через 5с и вернет строку 'Promise Data'.
Создайте второй промис, который перейдет в состояние rejected по клику на кнопку. Добавьте обработчик для кнопки.
Используя метод race организуйте отмену промиса.
1. Создайте асинхронную функцию myFirstAsyncFunction, используя FD (Function Declaration). Функция должна принимать два параметра a и b и возвращать сумму `a+b`.   
Выведите значение, которое вернет функция в консоль. Обработаете промис и выведите значение в консоль.
1. Cоздайте функцию makeRequest, используя FD (Function Declaration).  
Функция должна принимать один параметр - url и возвращать промис, который перейдет в состояние resolved через 2с. и вернет значение параметра.
Первой строкой в функции выведите сообщение 'makeRequest is called'.  
Cоздайте функцию mySecondAsyncFunction, используя FD (Function Declaration).  
Функция должна вызвать функцию makeRequest, получить результат ее работы и вывести в консоль.
1. Создайте масив урлов `['http://a', 'http://b']`.  Создайте функцию sendRequest, которая принимает один параметр - url.
Функция в первой строке должна выводить в консоль сообщение `'sendRequest is called'` и возвращать через 2 с для первого урла объект `{ name: 'Ann' }`, а для второго урла объект `{ age: 16 }`.
Создайте асинхронную функцию myThirdAsyncFunction которая должна вызвать функцию sendRequest для каждого урла и вернуть объект `{name: 'Ann', age: 16}`.  
Обработайте результат работы функции myThirdAsyncFunction.
